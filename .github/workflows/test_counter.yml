name: Count test cases & publish badge

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  count-and-publish:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Rust (stable)
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
          profile: minimal

      - name: Cache cargo registry & target
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Build tests (compile, do not run)
        run: |
          # compile tests so test binaries exist (helps `--list` in some cases)
          cargo test --all --no-run || true

      - name: Count test cases (try JSON mode, fallback to text parsing)
        id: count_tests
        run: |
          set -euo pipefail

          echo "Attempting JSON listing (cargo test -- --list --format=json)..."

          # try JSON listing first
          json_out=$(mktemp)
          if cargo test --all -- --list --format=json 2>/dev/null | tee "${json_out}"; then
            # Count JSON lines whose "type" is "test"
            count=$(python3 - <<'PY'
import sys, json
cnt = 0
for line in sys.stdin:
    try:
        obj = json.loads(line)
    except Exception:
        continue
    if obj.get("type") == "test":
        cnt += 1
print(cnt)
PY
 < "${json_out}")
          else
            # Fallback: use text listing (older cargo/test harness)
            echo "JSON listing unsupported or failed â€” falling back to text parsing."
            # capture text listing
            text_out=$(mktemp)
            cargo test --all -- --list 2>/dev/null | tee "${text_out}" || true

            # Heuristic: count lines that look like test entries.
            # Typical lines are: "<test_name> - <desc>" or "<testname>" or "test <name> ...".
            # We'll count lines that contain "test" output formats and common patterns.
            count=$(grep -E '^[[:alnum:]_].*' "${text_out}" \
                      | grep -vE '^\s*$' \
                      | wc -l | tr -d ' ')
            # If the grep above returns suspiciously large numbers, tighten heuristic:
            # Count lines containing '::' (module separators) or parentheses may indicate test names.
            if [ "${count}" -eq "0" ]; then
              count=$(grep -E '::' "${text_out}" | wc -l | tr -d ' ')
            fi
          fi

          # Ensure count is numeric
          if ! echo "${count}" | grep -E '^[0-9]+$' >/dev/null 2>&1; then
            echo "0" > /tmp/testcount || true
            count=0
          fi

          echo "Found ${count} test cases."
          echo "count=${count}" >> $GITHUB_OUTPUT

      - name: Create JSON badge
        run: |
          mkdir -p badges
          COUNT=${{ steps.count_tests.outputs.count }}
          # choose color based on count (cute touch)
          if [ "$COUNT" -eq "0" ]; then
            COLOR="lightgrey"
          elif [ "$COUNT" -lt "10" ]; then
            COLOR="yellow"
          else
            COLOR="brightgreen"
          fi
          cat > badges/test-cases.json <<EOF
{"schemaVersion":1,"label":"test-cases","message":"${COUNT}","color":"${COLOR}"}
EOF
          ls -la badges
          cat badges/test-cases.json

      - name: Publish badge to gh-pages (push single file)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Prepare an orphan branch with only the badges directory
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Create a temp worktree to avoid losing files in current repo state
          TMP_DIR=$(mktemp -d)
          git worktree add --detach "$TMP_DIR" || true
          cd "$TMP_DIR"

          # Init a clean git repo in temp dir, set remote
          git init
          git remote add origin "https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"

          mkdir -p badges
          # Copy badge JSON from the checkout workspace
          cp -r "${GITHUB_WORKSPACE}/badges/test-cases.json" badges/test-cases.json

          git add badges/test-cases.json
          git commit -m "Update test-cases badge: ${COUNT}" || true
          # Force push to gh-pages branch (only the badges file will be there)
          git push -f origin HEAD:gh-pages

          # cleanup
          cd /
          rm -rf "$TMP_DIR"

      - name: Output badge URL
        run: |
          echo "Badge JSON published at:"
          echo "https://raw.githubusercontent.com/${{ github.repository }}/gh-pages/badges/test-cases.json"
